## Порівняння ефективності: жадібний алгоритм vs динамічне програмування

### Вихідні вимірювання часу виконання
(час наведений для `number = 1000` запусків)

- **Сума: 521**
  - Жадібний алгоритм: `0.000284 s`  
    (~`2.84 × 10⁻⁷ s` за один запуск)
  - Динамічне програмування: `0.1814 s`  
    (~`1.81 × 10⁻⁴ s` за один запуск)

- **Сума: 9653**
  - Жадібний алгоритм: `0.0004268 s`  
    (~`4.27 × 10⁻⁷ s` за один запуск)
  - Динамічне програмування: `4.0439 s`  
    (~`4.04 × 10⁻³ s` за один запуск)

- **Сума: 54328**
  - Жадібний алгоритм: `0.0003326 s`  
    (~`3.33 × 10⁻⁷ s` за один запуск)
  - Динамічне програмування: `21.2808 s`  
    (~`2.13 × 10⁻² s` за один запуск)

З отриманих результатів видно, що при збільшенні суми час виконання алгоритму динамічного програмування зростає дуже суттєво, тоді як час роботи жадібного алгоритму майже не змінюється.

---

## Асимптотична складність (O-велике)

### Жадібний алгоритм (`find_coins_greedy`)
- **Часова складність:** `O(k)`, де `k` — кількість номіналів монет  
  (у даному випадку `k = 6`, тобто практично `O(1)`).
- **Просторова складність:** `O(1)`.

Жадібний алгоритм проходиться лише по списку монет і не залежить від величини суми, тому його швидкодія залишається стабільною навіть для дуже великих значень.

---

### Алгоритм динамічного програмування (`find_min_coins`)
- **Часова складність:** `O(amount × k)`.
- **Просторова складність:** `O(amount)`.

Алгоритм будує таблицю оптимальних рішень для всіх сум від `1` до `amount`. Тому зі збільшенням суми лінійно зростає як час виконання, так і використання пам’яті.

---

## Поведінка алгоритмів на великих сумах

### Жадібний алгоритм
- Працює майже з однаковою швидкістю для малих і великих сум.
- Добре масштабується.
- Підходить для касових систем із класичними номіналами монет.
- Не гарантує оптимальність для довільних наборів номіналів, але для стандартних систем працює коректно.

### Динамічне програмування
- Завжди знаходить мінімальну кількість монет.
- Значно повільніше працює для великих сум.
- Споживає більше пам’яті.
- Доцільне для задач із нестандартними номіналами або коли оптимальність важливіша за швидкодію.

---

## Порівняльна таблиця

| Критерій                             | Жадібний алгоритм| Динамічне програмування |
|--------------------------------------|------------------|-------------------------|
| Часова складність                    |      `O(k)`      |      `O(amount × k)`    |
| Просторова складність                |      `O(1)`      |        `O(amount)`      |
| Швидкодія на великих сумах           |      Висока      |          Низька         |
| Гарантія мінімальної кількості монет |         Ні       |           Так           |
| Придатність для касових систем       |       Висока     |         Обмежена        |

---

## Висновок

Жадібний алгоритм є найбільш ефективним рішенням для касових систем зі стандартними номіналами монет, оскільки він працює дуже швидко та не залежить від величини суми.  
Алгоритм динамічного програмування, хоча й гарантує мінімальну кількість монет, має значно гіршу продуктивність на великих сумах через лінійне зростання часу та використання пам’яті.  

Таким чином, вибір алгоритму залежить від вимог задачі: швидкодія та масштабованість або гарантована оптимальність.
