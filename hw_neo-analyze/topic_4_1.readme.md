Висновки щодо ефективності алгоритмів сортування

Аналіз швидкодії Insertion sort, Merge sort та вбудованого Python-сортування (Timsort) за результатами двох експериментів.

Було проведено незалежні запуски сортувань для трьох діапазонів розмірів списків:
    10–50 елементів
    100–200 елементів
    400–600 елементів

У кожному випадку вимірювався час роботи:
    Insertion sort (O(n²))
    Merge sort (O(n log n))
    sorted() у Python — Timsort (гібридний алгоритм)

1. Малі списки (10–50 елементів)
Алгоритм	Час (сек) — середнє
    Insertion sort	~0.0020
    Merge sort	~0.0200
    Timsort	~0.00023
✔ Висновок
    Insertion sort працює доволі швидко на малих обсягах.
    Merge sort — несподівано повільний для цього розміру (накладні витрати на рекурсію та копіювання масивів).
    Timsort — найкращий, оскільки оптимізований саме для малих списків.

2. Середні списки (100–200 елементів)
Алгоритм	Час (сек) — середнє
    Insertion sort	~0.008
    Merge sort	~0.105
    Timsort	~0.00074
✔ Висновок
    Insertion sort вже відчутно сповільнюється, але все ще працює краще за Merge sort.
    Merge sort залишається повільним, бо створює багато проміжних списків.
    Timsort знову найшвидший з великим відривом.

3. Великі списки (400–600 елементів)
Алгоритм	Час (сек) — середнє
    Insertion sort	~0.039
    Merge sort	~0.442
    Timsort	~0.0028
✔ Висновок
Insertion sort логічно сповільнюється через O(n²), але поводиться навіть краще, ніж очікувалось.
Merge sort знову демонструє найбільший час — основна причина: Python-реалізація створює нові списки на кожній операції злиття.
Timsort залишається абсолютним лідером: швидкий, адаптивний і оптимізований під Python.

Підсумкові висновки:
Timsort (sorted) — найефективніший у всіх діапазонах.
    Він у 10–200 разів швидший за інші варіанти. Це пояснюється тим, що:
    він використовує комбінацію insertion sort + merge sort;
    адаптується до частково відсортованих даних;
    оптимізований на рівні C.

Insertion sort — не такий поганий, як очікується.
    Для малих і середніх списків він справді працює швидко, тому що:
    використовує лише операції порівняння та перестановки;
    в Python списки реалізовані ефективно;
    немає додаткових витрат на рекурсію.
    Але складність O(n²) робить його непридатним для великих даних.

Merge sort — найповільніший у Python у цій реалізації.
    Попри те, що теоретично він має складність O(n log n), на практиці він програє через:
    створення багатьох проміжних списків;
    рекурсію;
    повільне копіювання елементів Python-списків.
    Тобто ця реалізація — не оптимізована для реального застосування.

У цьому тестуванні найкращу ефективність демонструє Timsort (вбудована функція sorted).
Він стабільно працює у десятки разів швидше за Merge sort та у кілька разів швидше за Insertion sort.
Insertion sort виявився швидким на малих обсягах, але непридатним для великих списків через квадратичну складність.
Реалізація Merge sort у Python виявилася найповільнішою через накладні витрати на рекурсію та копіювання списків.
