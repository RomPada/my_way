
# Декоратори в Python — це інструмент, який дозволяє змінювати поведінку функцій або методів 
# без зміни їхнього вихідного коду


def complicatedqq(x: int, y: int) -> int: # оголошуємо функцію complicated, яка приймає два числа x і y; підказки типів: обидва — int, повертаємо int
    return x + y # логіка: просто скласти x + y.

from functools import wraps
def logger(func): # оголошуємо функцію-декоратор logger, яка приймає іншу функцію func (тобто ми будемо “обгортати” її додатковою поведінкою)
    @wraps(func) # functools.wraps(func) застосовується до внутрішньої функції inner. Вона "копіює" метадані (ім'я функції, документацію тощо) від func до inner. Завдяки цьому, коли ми викликаємо print(complicated.__name__), ми отримуємо метадані оригінальної функції complicated, а не функції inner з декоратору logger.
    def inner(x: int, y: int) -> int: # всередині створюємо внутрішню функцію-обгортку inner, яка приймає ті самі аргументи, що й func (у нашому прикладі — x, y); саме inner і робитиме “додаткову магію” (логування), а потім викличе func
        print(f"Викликається функція: {func.__name__}: {x}, {y}") # перед викликом оригінальної функції друкуємо повідомлення
        result = func(x, y) # викликаємо оригінальну функцію з тими ж аргументами та зберігаємо відповідь у result (у нашому випадку це буде x + y)
        print(f"Функція {func.__name__} завершила виконання: {result}") # після виконання — друкуємо ще одне лог-повідомлення з результатом
        return result # повертаємо результат далі, щоб “зовнішній світ” отримав саме значення, яке повернула початкова функція.

    return inner # декоратор logger повертає обгортку inner (а не викликає її тут!); важливо: inner — це замикання: вона “пам’ятає” func, яку ми обгорнули

# Далі ми беремо оригінальну complicated і замінюємо її на обгорнуту версію:
# викликаємо logger(complicated) → отримаємо функцію inner, яка логуватиме виклик і результат;
# присвоюємо назад у змінну complicated.
# Після цього complicated — уже не проста сума, а “сума з логами”.
complicated = logger(complicatedqq)
print(complicatedqq(2, 3))
print(complicated.__name__) # доказ, що дякуючи @wraps(func) виконувалась оригінальна complicated, а не inner

# вигляд з декоратором
@logger
def complicated(x: int, y: int) -> int:
    return x + y